# ==============================================================================
# File 04: Full Spatiotemporal Interaction Models (STANDALONE VERSION)
# ==============================================================================
# This file loads previous results and develops non-separable interaction models
# STANDALONE - loads all required data from saved results without re-running phases
#
# DEVELOPMENT PHASE 4: Full Spatiotemporal Interaction Models
# - Load all previous phase results efficiently  
# - Focus on most promising interactions (AR1-based from Phase 3)
# - Remove problematic arbitrary regional grouping
# - Compare computational cost vs minimal performance benefit using ZIP
# - Confirm separability conclusion from Phase 3
# ==============================================================================

# Clear environment and load libraries
rm(list = ls())
suppressPackageStartupMessages({
  library(INLA)
  library(dplyr)
  library(ggplot2)
  library(gridExtra)
  library(viridis)
  library(Matrix)
  library(scales)
  library(lubridate)
  library(parallel)
})

# Load shared utilities
source("00_model_utilities.r")

# Detect OS and set up parallel processing
setup_parallel <- function(n_cores = NULL) {
  if (is.null(n_cores)) {
    n_cores <- min(detectCores() - 1, 10)  # Leave 1 core free, max 10
  }
  
  if (.Platform$OS.type == "unix") {
    # Mac/Linux - use mclapply (simpler)
    return(list(type = "mclapply", cores = n_cores))
  } else {
    # Windows - need to create cluster
    cl <- makeCluster(n_cores)
    return(list(type = "cluster", cluster = cl, cores = n_cores))
  }
}

# Get response type from environment variable
RESPONSE_TYPE <- Sys.getenv("ANALYSIS_RESPONSE_TYPE", unset = "opioid")
PARALLEL <- as.logical(Sys.getenv("ANALYSIS_PARALLEL", unset = "TRUE"))

cat("=== PHASE 4: FULL SPATIOTEMPORAL INTERACTION MODELS (STANDALONE) ===\n")
cat("Response variable:", RESPONSE_TYPE, "\n")
cat("Loading saved results from previous phases...\n\n")

# Set INLA options
if (PARALLEL) {
  INLA::inla.setOption(num.threads = "1:1")
}

# ==============================================================================
# 1. LOAD ALL REQUIRED DATA FROM PHASE 00 SPLITS
# ==============================================================================

cat("--- Step 1: Loading Required Data from Fixed Phase 00 ---\n")

# Function to safely load required files
safe_load_required <- function(filename, description) {
  if (file.exists(filename)) {
    result <- readRDS(filename)
    cat("✓ Loaded", description, "\n")
    return(result)
  } else {
    stop("✗ Missing required file: ", filename, " - Run Phase 00 first")
  }
}

# Load essential data
CONFIG <- safe_load_required("outputs/data/config.rds", "configuration (from Phase 00)")
precision_matrices <- safe_load_required("outputs/data/precision_matrices.rds", "precision matrices")

# Load the EXACT same splits generated by Phase 00
if (RESPONSE_TYPE == "opioid") {
  data_splits <- safe_load_required("outputs/data/opioid_splits.rds", "opioid splits (from Phase 00)")
} else {
  data_splits <- safe_load_required("outputs/data/stimulant_splits.rds", "stimulant splits (from Phase 00)")
}

# Load Phase 3 results for comparison (required)
phase3_results <- safe_load_required(paste0("outputs/models/phase3_spatiotemporal_", RESPONSE_TYPE, ".rds"), "Phase 3 separable results")

cat("✓ All required data loaded successfully\n")
cat("✓ Model family:", CONFIG$FAMILY, "(Zero-Inflated Poisson)\n")
cat("✓ Holdout configuration:", CONFIG$HOLDOUT_MONTHS, "months (from Phase 00)\n")

# Verify the splits configuration
cat("✓ Training data size:", nrow(data_splits$train), "observations\n")
cat("✓ Test data size:", nrow(data_splits$test), "observations\n")
cat("✓ Holdout starts at time_id:", data_splits$holdout_start_time, "\n")

# Extract key info from Phase 3
best_separable <- phase3_results$best_models$overall
cat("✓ Phase 3 best model:", best_separable$model_name, "(WAIC =", round(best_separable$waic, 1), ")\n")

# ==============================================================================
# 2. PREPARE INTERACTION DATA MATCHING PHASE 00 SPLITS
# ==============================================================================

cat("\n--- Step 2: Preparing Interaction Data ---\n")

# Use the training data from Phase 00 splits
# This must match exactly what Phase 05 will expect
train_interaction_data <- data_splits$train %>%
  filter(Residence_County %in% precision_matrices$county_names) %>%
  mutate(
    # Basic indices (matches Phase 00 structure)
    spatial_id = match(Residence_County, precision_matrices$county_names),
    time_numeric = as.numeric(time_id),
    
    # Create interaction indices for space-time models
    space_time_idx = (spatial_id - 1) * max(time_id) + time_id,
    
    # Create duplicate spatial indices for INLA (required for complex models)
    spatial_id2 = spatial_id,
    spatial_id3 = spatial_id,
    
    # Period groupings that work with 6-month holdout from Phase 00
    # With 6-month holdout, we have time_id up to 102
    max_train_time = max(time_id),
    
    # Adjust period boundaries based on actual training data range
    pre_intervention_period = ifelse(time_id <= 60, 1, 0),   # Jan 2015 - Dec 2019 
    implementation_period = ifelse(time_id > 60 & time_id <= 96, 1, 0),  # Jan 2020 - Dec 2022 
    assessment_period = ifelse(time_id > 96, 1, 0),          # Jan 2023 onwards
    
    # Seasonal indicators  
    season = case_when(
      month(date) %in% c(12, 1, 2) ~ "winter",
      month(date) %in% c(3, 4, 5) ~ "spring", 
      month(date) %in% c(6, 7, 8) ~ "summer",
      month(date) %in% c(9, 10, 11) ~ "fall"
    ),
    season_id = as.numeric(factor(season))
  ) %>%
  arrange(spatial_id, time_id)

cat("✓ Prepared interaction data structure from Phase 00 splits\n")
cat("✓ Training observations:", nrow(train_interaction_data), "\n")
cat("✓ Space-time combinations:", length(unique(train_interaction_data$space_time_idx)), "\n")
cat("✓ Training time range: time_id", min(train_interaction_data$time_id), "to", max(train_interaction_data$time_id), "\n")
cat("✓ Using epidemiologically-justified periods:\n")
cat("  • Pre-intervention (2015-2019): Baseline epidemic patterns\n") 
cat("  • Implementation (2020-2022): WV Response Plan + COVID impacts\n")
cat("  • Assessment (2023): Post-implementation evaluation, final 6 months for all counties are the testing set\n")

# Verification: Check assessment period learning
assessment_in_train <- sum(train_interaction_data$assessment_period == 1, na.rm = TRUE)
cat("✓ Assessment period observations in training:", assessment_in_train, "\n")

if (assessment_in_train > 0) {
  cat("✓ All epidemiologically-justified period interactions are now learnable with final 6-month holdout\n")
} else {
  cat("⚠️  WARNING: Assessment period still not in training data\n")
  cat("   Check Phase 00 holdout configuration\n")
}

# Verify data dimensions will match Phase 05 expectations
cat("\nDimension verification for Phase 05 compatibility:\n")
cat("✓ Counties with spatial data:", length(precision_matrices$county_names), "\n")
cat("✓ Training data will be", nrow(train_interaction_data), "observations for Phase 05\n")
cat("✓ This will be the size of model$summary.fitted.values\n")

# ==============================================================================
# 3. DEFINE LIMITED INTERACTION MODEL SPECIFICATIONS
# ==============================================================================

cat("\n--- Step 3: Defining Interaction Model Specifications ---\n")

# Based on Phase 3 results showing AR1 temporal + adjacency/exponential/gaussian spatial perform best
interaction_models <- list(
  
  # === BASIC SPACE-TIME INTERACTIONS ===
  
  # 1. Adjacency + AR1 + Space-Time Interaction
  adjacency_ar1_interaction = list(
    name = "Adjacency + AR1 + Space-Time Interaction",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1",
      random = c("f(spatial_id, model='generic', Cmatrix=Q_adj, rankdef=1, constr=TRUE)",
                 "f(time_id, model='ar1')",
                 "f(space_time_idx, model='iid')"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$adjacency,
    complexity_score = 5,
    description = "Adjacency spatial + AR1 temporal + space-time interaction"
  ),
  
  # 2. Exponential + AR1 + Space-Time Interaction  
  exponential_ar1_interaction = list(
    name = "Exponential + AR1 + Space-Time Interaction",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1",
      random = c("f(spatial_id, model='generic', Cmatrix=Q_exp, rankdef=1, constr=TRUE)",
                 "f(time_id, model='ar1')",
                 "f(space_time_idx, model='iid')"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$exponential,
    complexity_score = 5,
    description = "Exponential spatial + AR1 temporal + space-time interaction"
  ),
  
  # 3. Gaussian + AR1 + Space-Time Interaction
  gaussian_ar1_interaction = list(
    name = "Gaussian + AR1 + Space-Time Interaction",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1",
      random = c("f(spatial_id, model='generic', Cmatrix=Q_gauss, rankdef=1, constr=TRUE)",
                 "f(time_id, model='ar1')",
                 "f(space_time_idx, model='iid')"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$gaussian,
    complexity_score = 5,
    description = "Gaussian spatial + AR1 temporal + space-time interaction"
  ),
  
  # === TIME-VARYING SPATIAL CORRELATIONS ===
  
  # 4. Time-Varying Adjacency
  adjacency_timevarying = list(
    name = "Time-Varying Adjacency Spatial",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1",
      random = c("f(time_id, model='ar1')",
                 "f(spatial_id, model='generic', Cmatrix=Q_adj, group=time_id, rankdef=1, constr=TRUE)"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$adjacency,
    complexity_score = 6,
    description = "AR1 temporal with time-varying adjacency spatial effects"
  ),
  
  # 5. Time-Varying Exponential
  exponential_timevarying = list(
    name = "Time-Varying Exponential Spatial",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1",
      random = c("f(time_id, model='ar1')",
                 "f(spatial_id, model='generic', Cmatrix=Q_exp, group=time_id, rankdef=1, constr=TRUE)"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$exponential,
    complexity_score = 6,
    description = "AR1 temporal with time-varying exponential spatial effects"
  ),
  
  # === SEASONAL INTERACTIONS ===
  
  # 6. Seasonal-Varying Adjacency
  adjacency_seasonal = list(
    name = "Seasonal-Varying Adjacency",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1",
      random = c("f(time_id, model='ar1')",
                 "f(spatial_id, model='generic', Cmatrix=Q_adj, group=season_id, rankdef=1, constr=TRUE)"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$adjacency,
    complexity_score = 5,
    description = "AR1 temporal + season-varying adjacency spatial effects"
  ),
  
  # 7. Seasonal-Varying Exponential
  exponential_seasonal = list(
    name = "Seasonal-Varying Exponential",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1", 
      random = c("f(time_id, model='ar1')",
                 "f(spatial_id, model='generic', Cmatrix=Q_exp, group=season_id, rankdef=1, constr=TRUE)"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$exponential,
    complexity_score = 5,
    description = "AR1 temporal + season-varying exponential spatial effects"
  ),
  
  # === TEMPORAL STRUCTURE VARIATIONS ===
  
  # 8. Adjacency + RW1 + Space-Time Interaction
  adjacency_rw1_interaction = list(
    name = "Adjacency + RW1 + Space-Time Interaction", 
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1",
      random = c("f(spatial_id, model='generic', Cmatrix=Q_adj, rankdef=1, constr=TRUE)",
                 "f(time_id, model='rw1')",
                 "f(space_time_idx, model='iid')"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$adjacency,
    complexity_score = 5,
    description = "Adjacency spatial + RW1 temporal + space-time interaction"
  ),
  
  # 9. Adjacency + RW2 + Space-Time Interaction
  adjacency_rw2_interaction = list(
    name = "Adjacency + RW2 + Space-Time Interaction",
    formula_parts = list(
      response = "distinct_patient_count", 
      fixed = "1",
      random = c("f(spatial_id, model='generic', Cmatrix=Q_adj, rankdef=1, constr=TRUE)",
                 "f(time_id, model='rw2')",
                 "f(space_time_idx, model='iid')"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$adjacency,
    complexity_score = 6,
    description = "Adjacency spatial + RW2 temporal + space-time interaction"
  ),
  
  # === EPIDEMIC PERIOD INTERACTIONS ===
  
  # 10. Epidemiologically-Justified Period Interactions (Adjacency)
  adjacency_ar1_period = list(
    name = "Adjacency + AR1 + Policy-Aligned Period Interactions",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "pre_intervention_period + implementation_period + assessment_period",
      random = c("f(time_id, model='ar1')",
                 "f(spatial_id, model='generic', Cmatrix=Q_adj, rankdef=1, constr=TRUE)",
                 "f(spatial_id2, pre_intervention_period, model='generic', Cmatrix=Q_adj, rankdef=1, constr=TRUE)",
                 "f(spatial_id3, implementation_period, model='generic', Cmatrix=Q_adj, rankdef=1, constr=TRUE)"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$adjacency,
    complexity_score = 8,
    description = "AR1 + policy-aligned spatial patterns (pre-intervention, implementation, assessment)"
  ),
  
  # 11. Epidemiologically-Justified Period Interactions (Exponential)
  exponential_ar1_period = list(
    name = "Exponential + AR1 + Policy-Aligned Period Interactions",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "pre_intervention_period + implementation_period + assessment_period",
      random = c("f(time_id, model='ar1')",
                 "f(spatial_id, model='generic', Cmatrix=Q_exp, rankdef=1, constr=TRUE)",
                 "f(spatial_id2, pre_intervention_period, model='generic', Cmatrix=Q_exp, rankdef=1, constr=TRUE)",
                 "f(spatial_id3, implementation_period, model='generic', Cmatrix=Q_exp, rankdef=1, constr=TRUE)"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$exponential,
    complexity_score = 8,
    description = "AR1 + policy-aligned exponential spatial patterns (pre-intervention, implementation, assessment)"
  ),
  
  # === COMPLEX INTERACTIONS ===
  
  # 12. Full Space-Time-Season Interaction
  adjacency_ar1_seasonal_interaction = list(
    name = "Full Space-Time-Season Interaction",
    formula_parts = list(
      response = "distinct_patient_count",
      fixed = "1",
      random = c("f(spatial_id, model='generic', Cmatrix=Q_adj, rankdef=1, constr=TRUE)",
                 "f(time_id, model='ar1')",
                 "f(season_id, model='iid')",
                 "f(space_time_idx, model='iid')"),
      offset = "log_pop_offset"
    ),
    spatial_matrix = precision_matrices$adjacency,
    complexity_score = 6,
    description = "Adjacency + AR1 + seasonal + space-time interaction"
  )
)

cat("✓ Defined", length(interaction_models), "comprehensive interaction models\n")
cat("Note: Extensive testing to provide stakeholder confidence in separability or interaction conclusion\n")
cat("Categories: Basic interactions, time-varying spatial, seasonal, temporal variations, period-specific\n")

# ==============================================================================
# 4. FIT INTERACTION MODELS
# ==============================================================================

cat("\n--- Step 4: Fitting Interaction Models ---\n")

# Function to create formula from parts
create_interaction_formula <- function(formula_parts) {
  response <- formula_parts$response
  fixed <- formula_parts$fixed
  random <- formula_parts$random
  offset <- formula_parts$offset
  
  formula_str <- paste(response, "~", fixed)
  
  if (!is.null(random) && length(random) > 0) {
    formula_str <- paste(formula_str, "+", paste(random, collapse = " + "))
  }
  
  if (!is.null(offset)) {
    formula_str <- paste(formula_str, "+ offset(", offset, ")")
  }
  
  as.formula(formula_str)
}

# Function to fit a single interaction model
fit_interaction_model <- function(model_spec, train_data, model_name) {
  
  start_time <- Sys.time()
  
  # Set up precision matrices in global environment
  if (!is.null(model_spec$spatial_matrix)) {
    if (grepl("adjacency", model_name, ignore.case = TRUE)) {
      assign("Q_adj", model_spec$spatial_matrix, envir = .GlobalEnv)
    } else if (grepl("exponential", model_name, ignore.case = TRUE)) {
      assign("Q_exp", model_spec$spatial_matrix, envir = .GlobalEnv)
    } else if (grepl("gaussian", model_name, ignore.case = TRUE)) {
      assign("Q_gauss", model_spec$spatial_matrix, envir = .GlobalEnv)
    } else {
      # Default fallback
      assign("Q_adj", model_spec$spatial_matrix, envir = .GlobalEnv)
    }
  }
  
  # Create formula
  formula <- create_interaction_formula(model_spec$formula_parts)
  
# Fit model with proper error handling
  tryCatch({
    result <- fit_model_with_zinb_support(formula, train_data, CONFIG$FAMILY)
  
    end_time <- Sys.time()
    runtime <- as.numeric(difftime(end_time, start_time, units = "secs"))
  
    # Check for successful fit
    if (is.null(result) || any(is.na(result$summary.fixed))) {
      cat("Fitting", model_name, "model (complexity:", model_spec$complexity_score, ") FAILED\n")
      return(list(
        model = NULL,
        fit_success = FALSE,
        error_message = "Model fitting failed",
        runtime = runtime
      ))
    }
  
    # Print complete success message
    cat("Fit", model_name, "model (complexity:", model_spec$complexity_score, ") ✓ (", round(runtime, 1), "s)\n")
  
    return(list(
      model = result,
      model_spec = model_spec,
      fit_success = TRUE,
      runtime = runtime,
      formula = formula
    ))
  
  }, error = function(e) {
    end_time <- Sys.time()
    runtime <- as.numeric(difftime(end_time, start_time, units = "secs"))
  
    cat("Fitting", model_name, "model (complexity:", model_spec$complexity_score, ") ERROR:", e$message, "\n")
    return(list(
      model = NULL,
      fit_success = FALSE,
      error_message = e$message,
      runtime = runtime
    ))
  })
}

cat("Fitting interaction models in parallel...\n")
parallel_env <- setup_parallel(n_cores = 6)  
cat("Using", parallel_env$cores, "cores\n\n")

# Status update
cat("Fitting", length(interaction_models), "models on", parallel_env$cores, "cores\n")

if (parallel_env$type == "mclapply") {
  # Mac/Linux
  interaction_results <- mclapply(names(interaction_models), function(model_name) {
    model_spec <- interaction_models[[model_name]]
    fit_interaction_model(model_spec, train_interaction_data, model_name)
  }, mc.cores = parallel_env$cores)
  
} else {
  # Windows
  clusterEvalQ(parallel_env$cluster, {
    library(INLA)
    library(dplyr)
    source("00_model_utilities.r")
  })
  clusterExport(parallel_env$cluster, c("train_interaction_data", "precision_matrices", "CONFIG", 
                                        "fit_interaction_model", "interaction_models",
                                        "create_interaction_formula", "fit_model_with_zinb_support"))
  
  interaction_results <- parLapply(parallel_env$cluster, names(interaction_models), function(model_name) {
    model_spec <- interaction_models[[model_name]]
    fit_interaction_model(model_spec, train_interaction_data, model_name)
  })

  cat("Starting", length(interaction_models), "models...\n")
  completed <- 0

  for (result in interaction_results) {
  completed <- completed + 1
  cat("\rCompleted:", completed, "/", length(interaction_models))
  }
  cat("\n")
  
  # Report model fit times
  for (i in seq_along(interaction_results)) {
    result <- interaction_results[[i]]
    model_name <- names(interaction_models)[i]
    if (result$fit_success) {
      cat("✓", model_name, "(", round(result$runtime, 1), "s)\n")
    } else {
      cat("✗", model_name, "FAILED\n")
    }
  }

  stopCluster(parallel_env$cluster)

}

# Set names on results
names(interaction_results) <- names(interaction_models)
successful_interactions <- sum(sapply(interaction_results, function(x) x$fit_success))
total_models <- length(interaction_models)


cat("\n✓ Successfully fit", successful_interactions, "out of", total_models, "interaction models\n")

# Define for later use
successful_fits <- successful_interactions
total_models <- length(interaction_models)

# ==============================================================================
# 5. COMPREHENSIVE MODEL COMPARISON  
# ==============================================================================

cat("\n--- Step 5: Comprehensive Model Comparison ---\n")

# Extract interaction model metrics
extract_interaction_metrics <- function(model_result, model_name) {
  if (!model_result$fit_success) {
    return(data.frame(
      model_name = model_name,
      model_type = "interaction",
      complexity_score = model_result$model_spec$complexity_score,
      dic = NA, waic = NA, marginal_likelihood = NA,
      mean_cpo = NA, failure_rate = NA, runtime_seconds = model_result$runtime,
      fit_success = FALSE,
      stringsAsFactors = FALSE
    ))
  }
  
  model <- model_result$model
  spec <- model_result$model_spec
  
  # Calculate CPO metrics
  cpo_vals <- model$cpo$cpo
  if (is.null(cpo_vals)) {
    mean_cpo <- NA
    failure_rate <- NA
  } else {
    mean_cpo <- mean(cpo_vals, na.rm = TRUE)
    failure_rate <- sum(cpo_vals < 0.001, na.rm = TRUE) / length(cpo_vals)
  }
  
  data.frame(
    model_name = model_name,
    model_type = "interaction",
    complexity_score = spec$complexity_score,
    dic = model$dic$dic,
    waic = model$waic$waic,
    marginal_likelihood = model$mlik[1],
    mean_cpo = mean_cpo,
    failure_rate = failure_rate,
    runtime_seconds = model_result$runtime,
    fit_success = TRUE,
    stringsAsFactors = FALSE
  )
}

# Create interaction model comparison
interaction_metrics <- do.call(rbind, lapply(names(interaction_results), function(name) {
  extract_interaction_metrics(interaction_results[[name]], name)
})) %>%
  filter(fit_success == TRUE) %>%
  arrange(waic)

# Add Phase 3 separable models for comparison
separable_metrics <- phase3_results$comparison_metrics %>%
  filter(fit_success == TRUE) %>%
  arrange(waic) %>%
  mutate(
    runtime_seconds = runtime  # Only convert runtime, don't touch model_type
  ) %>%
  select(model_name, model_type, complexity_score, dic, waic, marginal_likelihood, 
         mean_cpo, failure_rate, runtime_seconds, fit_success)

# Combine all models
all_models_comparison <- rbind(
  interaction_metrics,
  separable_metrics
) %>%
  arrange(waic) %>%
  mutate(
    waic_rank = rank(waic),
    improvement_over_best_separable = best_separable$waic - waic,
    within_3_waic = (waic <= min(waic) + 3)
  )

# Display results
cat("Comprehensive Model Comparison (Interaction + Separable):\n")
print(head(all_models_comparison, 10))

# Find best models
best_overall <- all_models_comparison[1, ]
best_interaction <- all_models_comparison %>% 
  filter(model_type == "interaction") %>% 
  slice_min(waic, n = 1)

# Models within 3 WAIC units
models_within_3_waic <- all_models_comparison %>%
  filter(within_3_waic == TRUE) %>%
  arrange(waic)

cat("\n=== MODEL SELECTION RESULTS ===\n")
cat("Best overall model:", best_overall$model_name, "(", best_overall$model_type, 
    ", WAIC =", round(best_overall$waic, 1), ")\n")

if (nrow(models_within_3_waic) > 1) {
  cat("\nModels within 3 WAIC units (similar performance):\n")
  for (i in 1:min(5, nrow(models_within_3_waic))) {
    model <- models_within_3_waic[i, ]
    cat("  ", i, ".", model$model_name, "(", model$model_type, ", WAIC =", 
        round(model$waic, 1), ")\n")
  }
}

# Interaction vs Separable analysis
if (nrow(best_interaction) > 0) {
  interaction_improvement <- best_separable$waic - best_interaction$waic
  interaction_pct_improvement <- round((interaction_improvement / best_separable$waic) * 100, 3)
  
  cat("\n=== INTERACTION vs SEPARABLE ANALYSIS ===\n")

  # First calculate the response-scale metrics
  separable_model <- NULL
  interaction_model <- NULL
  mae_improvement <- NA
  rmse_improvement <- NA
  separable_mae <- NA
  interaction_mae <- NA
  separable_rmse <- NA
  interaction_rmse <- NA

  # Try to get models for response-scale metrics
  if (!is.null(phase3_results$model_fits[[best_separable$model_name]])) {
    separable_model <- phase3_results$model_fits[[best_separable$model_name]]$model
  }
  if (!is.null(interaction_results[[best_interaction$model_name]])) {
    interaction_model <- interaction_results[[best_interaction$model_name]]$model
  }

  # Calculate MAE/RMSE if both models available
  if (!is.null(separable_model) && !is.null(interaction_model) &&
      !is.null(separable_model$summary.fitted.values) &&
      !is.null(interaction_model$summary.fitted.values)) {
  
    separable_fitted <- separable_model$summary.fitted.values$mean
    interaction_fitted <- interaction_model$summary.fitted.values$mean
    observed <- train_interaction_data$distinct_patient_count
  
    if (length(separable_fitted) == length(observed) && 
        length(interaction_fitted) == length(observed)) {
    
      separable_mae <- mean(abs(observed - separable_fitted))
      interaction_mae <- mean(abs(observed - interaction_fitted))
      separable_rmse <- sqrt(mean((observed - separable_fitted)^2))
      interaction_rmse <- sqrt(mean((observed - interaction_fitted)^2))
    
      mae_improvement <- round((1 - interaction_mae/separable_mae) * 100, 1)
      rmse_improvement <- round((1 - interaction_rmse/separable_rmse) * 100, 1)
    }
  }

  # Now display everything together
  cat("Best separable (Phase 3):", best_separable$model_name, "\n")
  cat("  WAIC:", round(best_separable$waic, 1), "\n")
  if (!is.na(separable_mae)) {
    cat("  MAE:", round(separable_mae, 3), "deaths per county-month\n")
    cat("  RMSE:", round(separable_rmse, 3), "deaths per county-month\n")
  }

  cat("Best interaction (Phase 4):", best_interaction$model_name, "\n")
  cat("  WAIC:", round(best_interaction$waic, 1), "\n")
  if (!is.na(interaction_mae)) {
    cat("  MAE:", round(interaction_mae, 3), "deaths per county-month\n")
    cat("  RMSE:", round(interaction_rmse, 3), "deaths per county-month\n")
  }

  cat("\nImprovement metrics:\n")
  if (interaction_improvement > 0) {
    cat("  WAIC improvement:", round(interaction_improvement, 1), "units (", 
        interaction_pct_improvement, "%)\n")
    if (!is.na(mae_improvement)) {
      cat("  MAE improvement:", mae_improvement, "% reduction in error\n")
      cat("  RMSE improvement:", rmse_improvement, "% reduction in error\n")
    } else {
      cat("  MAE/RMSE: Could not calculate (fitted values unavailable)\n")
    }
    cat("  Runtime cost:", round(best_interaction$runtime_seconds / best_separable$runtime, 1), "x longer than separable\n")
  } else {
    cat("  Separable models perform equally well or better\n")
  }
  
  # Scientific conclusion about separability
  if (interaction_improvement < 7) {
    cat("\n*** SEPARABILITY IS BETTER ***\n")
    cat("Interaction improvement (", round(interaction_improvement, 1), 
        "WAIC units) is minimal, confirming that:\n")
    cat("• WV", RESPONSE_TYPE, "death patterns are separable into spatial + temporal components\n")
    cat("• No significant space-time interactions beyond additive effects\n") 
    cat("• Separable models are sufficient and more efficient\n")
  }
} else {
  cat("\nNo interaction models fit successfully\n")
}

# ==============================================================================
# 6. VISUALIZATION OF RESULTS
# ==============================================================================

cat("\n--- Step 6: Creating Visualizations ---\n")

# Create output directory for plots
dir.create("outputs/plots", showWarnings = FALSE, recursive = TRUE)

# 4. Top Models Comparison with WAIC Thresholds
  top_models <- all_models_comparison %>% 
  head(15) %>%  # Show more models to see differences
  arrange(waic)
  
  # Calculate WAIC differences from best model
  best_waic <- min(top_models$waic)
  top_models <- top_models %>%
  mutate(
    waic_diff = waic - best_waic,
    # Color categories based on WAIC differences
    waic_category = case_when(
      waic_diff == 0 ~ "Best Model",
      waic_diff <= 3 ~ "Equivalent (<=3 WAIC)",
      waic_diff <= 7 ~ "Moderate Diff (3-7 WAIC)", 
      waic_diff <= 20 ~ "Large Diff (7-20 WAIC)",
      TRUE ~ "Very Large Diff (>20 WAIC)"
    ),
    waic_category = factor(waic_category, levels = c("Best Model", "Equivalent (<=3 WAIC)", 
                                                    "Moderate Diff (3-7 WAIC)", 
                                                    "Large Diff (7-20 WAIC)", 
                                                    "Very Large Diff (>20 WAIC)")),
    # Add visual markers to distinguish separable models
    model_display = ifelse(model_type == "separable", 
                          paste0(model_name, " *"), 
                          model_name)
  )
  
  # Dynamic scale compression - focus on the actual range of top models
  waic_range <- max(top_models$waic) - min(top_models$waic)
  y_min <- best_waic - (waic_range * 0.1)  # Add 10% buffer below
  y_max <- max(top_models$waic) + (waic_range * 0.2)  # Add 20% buffer above for annotations
  
  top_models_plot <- ggplot(top_models, aes(x = reorder(model_display, -waic), y = waic)) +
  geom_col(aes(fill = waic_category), alpha = 0.8, width = 0.7) +
  geom_text(aes(label = round(waic, 0)), vjust = -0.5, size = 3) +
  # Add horizontal reference lines for WAIC thresholds
  geom_hline(yintercept = best_waic + 3, linetype = "dashed", color = "darkgray", alpha = 0.7) +
  geom_hline(yintercept = best_waic + 7, linetype = "dashed", color = "darkgray", alpha = 0.7) +
  geom_hline(yintercept = best_waic + 20, linetype = "dashed", color = "darkgray", alpha = 0.7) +
  # Custom colors for different WAIC categories
  scale_fill_manual(
    name = "Model Performance",
    values = c("Best Model" = "#2166ac", 
               "Equivalent (<=3 WAIC)" = "#5aae61", 
               "Moderate Diff (3-7 WAIC)" = "#fee08b", 
               "Large Diff (7-20 WAIC)" = "#fdae61", 
               "Very Large Diff (>20 WAIC)" = "#d73027")
  ) +
  # Compressed y-axis scale
  coord_cartesian(ylim = c(y_min, y_max)) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 8)) +
  theme_minimal() +
  labs(
    title = "Top Interaction + Separable Models (ZIP) - Compressed Scale",
    subtitle = paste("WAIC differences emphasized for", RESPONSE_TYPE, "deaths"),
    x = "Model", y = "WAIC (lower is better)",
    caption = "Dashed lines: +3, +7, +20 WAIC thresholds - Colors indicate performance tiers - Asterisk (*): separable models"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    legend.position = "bottom",
    plot.caption = element_text(size = 9, hjust = 0),
    plot.title = element_text(size = 14, face = "bold")
  ) +
  # Add threshold annotations
  annotate("text", x = 1, y = best_waic + 3, label = "+3 WAIC", 
           hjust = 0, vjust = -0.5, size = 3, color = "darkgray") +
  annotate("text", x = 1, y = best_waic + 7, label = "+7 WAIC", 
           hjust = 0, vjust = -0.5, size = 3, color = "darkgray") +
  annotate("text", x = 1, y = best_waic + 20, label = "+20 WAIC", 
           hjust = 0, vjust = -0.5, size = 3, color = "darkgray")


# Save plot
ggsave(paste0("outputs/plots/phase4_top_models", "_", RESPONSE_TYPE, ".png"), top_models_plot, 
           width = 12, height = 8, dpi = 300, bg = "white")

cat("✓ Created visualization plot\n")

# ==============================================================================
# 7. SAVE RESULTS AND FINAL RECOMMENDATION
# ==============================================================================

cat("\n--- Step 7: Saving Results ---\n")

# Create Phase 4 results
phase4_results <- list(
  response_type = RESPONSE_TYPE,
  model_family = CONFIG$FAMILY,
  interaction_models = interaction_models,
  interaction_results = interaction_results,
  all_models_comparison = all_models_comparison,
  best_models = list(
    overall_best = best_overall,
    best_interaction = if (nrow(best_interaction) > 0) best_interaction else NULL,
    best_separable_reference = best_separable,
    models_within_3_waic = models_within_3_waic
  ),
  separability_analysis = if (nrow(best_interaction) > 0) list(
    interaction_improvement = interaction_improvement,
    interaction_pct_improvement = interaction_pct_improvement,
    separability_confirmed = interaction_improvement < 10,
    recommendation = "Use separable models - minimal interaction benefit"
  ) else list(
    separability_confirmed = TRUE,
    recommendation = "Use separable models - interaction fitting failed"
  ),
  n_interaction_models = total_models,
  n_successful_fits = successful_fits,
  fitting_time = Sys.time()
)

# Save results
saveRDS(phase4_results, paste0("outputs/models/phase4_interaction_", RESPONSE_TYPE, ".rds"))
write.csv(all_models_comparison,
          paste0("outputs/models/phase4_all_models_comparison_", RESPONSE_TYPE, ".csv"),
          row.names = FALSE)

cat("✓ Phase 4 results saved to outputs/models/\n")
cat("✓ Plots saved to outputs/plots/\n")

# Final recommendation
cat("\n=== PHASE 4 FINAL RECOMMENDATION ===\n")

if (successful_fits > 0 && nrow(best_interaction) > 0) {
  if (phase4_results$separability_analysis$separability_confirmed) {
    cat("RECOMMENDATION: Use Phase 3 separable models\n")
    cat("• Best model:", best_separable$model_name, "(WAIC =", round(best_separable$waic, 1), ")\n")
    cat("• Interaction benefit: Minimal across", successful_fits, "interaction models tested\n")
    cat("• Computational efficiency: Separable models ~20x faster\n")
    cat("• Scientific conclusion: WV", RESPONSE_TYPE, "deaths show separable spatial-temporal patterns\n")
    cat("• Stakeholder confidence: Extensive interaction testing confirms separability\n")
    cat("• Model family: Zero-Inflated Poisson handles", round(mean(train_interaction_data$distinct_patient_count == 0)*100, 1), "% zero observations effectively\n")
  } else {
    cat("RECOMMENDATION: Consider interaction models\n")
    cat("• Best interaction:", best_interaction$model_name, "\n")
    cat("• Best separable (Phase 3):", best_separable$model_name, "\n") 
    cat("• Substantial interaction improvement:", round(interaction_improvement, 1), "WAIC units\n")
    cat("• Both models should be considered for final analysis\n")
  }
} else {
  cat("RECOMMENDATION: Use Phase 3 separable models\n")  
  cat("• Interaction models failed to fit or provide benefit\n")
  cat("• Confirms separability of spatial and temporal effects\n")
  cat("• Zero-Inflated Poisson family successfully handles highly zero-inflated data\n")
}

cat("\n✓ Phase 4 complete - ready for Phase 5 diagnostics\n")

# Clean up global environment
rm(list = ls(pattern = "^Q_"))

# ==============================================================================
# END OF PHASE 4 (STANDALONE)
# ==============================================================================